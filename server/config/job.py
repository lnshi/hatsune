#
# 'failed' status handles the condition: job failed to execute for unknown reason.
#
job_status = ('queued', 'scheduled', 'running', 'cancelled', 'failed', 'removed', 'completed')

job_events = ('submitted', 'scheduled', 'started', 'cancelled', 'failed', 'removed', 'completed')

def _check_job_status(status):
  if status in job_status:
    return True
  else:
    raise ValueError('Wrong job status: ' + status + '.\n' + 'Job status must be in ' + str(job_status) + '.')

def _check_job_events(event):
  if event in job_events:
    return True
  else:
    raise ValueError('Wrong job event: ' + event + '.\n' + 'Job event must be in ' + str(job_events) + '.')

#
# Model definition of Job.status_details.
#
class JobEventsDetail:

  def __init__(self, event, on_which_node, when):

    if _check_job_events(event):
      self.event = event

    self.on_which_node = on_which_node
    self.when = when

  def get_job_event_obj(self):
    return {
      'event': self.event,
      'on_which_node': self.on_which_node,
      'when': self.when
    }

#
# Model definition of job.
#
# To a job, only these three operations are provided:
#   start  -> job's status will be running.
#   cancel -> job's status will be cancelled.
#   remove -> job's status will be removed.
#
# 'job_id' is keyed in by user and must be unique.
# 'job_uuid' is generated by system when end user commit the job.
# 'on_unit' is 'on-unit', the command is currently waiting to be excuted.
# 'output_file' define where to put the job's output.
# 'status' must be in tuple 'job_status'
# 'status_details' should be an array which contains the instances of class 'JobStatusDetail'.
# 'scheduled_at' indicates when the scheduler scheduled the job, if None then need to schedule/re-schedule this job.
#
class Job:

  def __init__(self, job_id, job_uuid, on_unit, output_file, status, submitted_by, queued_at, status_details = None,
                scheduled_at = None):
    self.job_id = job_id
    self.job_uuid = job_uuid

    self.on_unit = on_unit

    self.output_file = output_file

    if _check_job_status(status):
      self.status = status

    self.submitted_by = submitted_by
    self.queued_at = queued_at

    self.status_details = status_details

    self.scheduled_at = scheduled_at

  def get_job_id(self):
    return self.job_id

  def get_job_uuid(self):
    return self.job_uuid

  def get_scheduled_at(self):
    return self.scheduled_at

  def set_scheduled_at(self, scheduled_at):
    self.scheduled_at = scheduled_at

  def set_status(self, status):
    if _check_job_status(status):
      self.status = status

  def get_job_json_obj(self):
    job_obj = {}
    for item in vars(self).items():
      if item[0] in ('job_id', 'on_unit', 'status', 'output_file', 'queued_at', 'submitted_by'):
        job_obj[item[0]] = item[1]
    return job_obj

  def get_command_obj(self):
    return {
      'uuid': self.job_uuid,
      'exec': self.on_unit,
      'out': self.output_file
    }

  def add_status_details(self, event_obj):
    if self.status_details:
      self.status_details.append(event_obj)
    else:
      self.status_details = [event_obj]

  def get_status_details(self):
    if self.status_details:
      temp = []
      for event_item in self.status_details:
        temp.append(event_item.get_job_event_obj())
      return temp
    else:
      return []


